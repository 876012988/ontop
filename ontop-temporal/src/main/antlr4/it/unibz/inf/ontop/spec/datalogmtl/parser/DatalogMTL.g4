
grammar DatalogMTL;

 /*
 Source files (Parser, Visitor, ...) are generated by the ANTLR4 Maven Plugin,
 during the Maven generate-sources phase.
 If src/main/<subPath>/TurtleOBDA.g4 is the path to this file,
 then the source files are generated in target/generated-sources/antlr4/<subPath>
 */


/*------------------------------------------------------------------
 * PARSER RULES
 *------------------------------------------------------------------*/

parse
  : prefixes base dMTLProgram EOF
  ;

prefixes
  : prefixID*
  ;

dMTLProgram
  : dMTLRule+
  ;

//directive
//  : base
//  | prefixID
//  ;

prefixID
  : ('prefix' | 'PREFIX') PNAME_NS IRIREF
  ;

base
  : ('base' | 'BASE') IRIREF
  ;

dMTLRule
  :  annotation? head ':-' body
  ;

annotation
  : '[' ('static' | 'STATIC') ']'
  ;

head
  : (temporalOperator temporalRange)? (triple | triple_with_dot)
  ;

body
  : expression* ('{' expression* '}')*  | ('{' body '}')  //expression+
  ;

//expression
//  : triple_with_dot+  ('('comparisonExpression')')* | ('{' expression '}')+ | (temporalOperator temporalRange '{' expression '}')+
//  ;

expression
  : triple_with_dot | filterExpression | temporalExpression
  ;

filterExpression
  : triple_with_dot '(' comparisonExpression ')'
  ;

//joinOfAtomicExpressions
//  : triple_with_dot triple_with_dot+
//  ;

temporalExpression
  : (temporalOperator temporalRange (triple_with_dot | temporalExpression)) | (temporalOperator temporalRange ('{' expression+ '}'))
  ;
//  : (temporalOperator temporalRange (triple_with_dot+ | temporalExpression)) |(temporalOperator temporalRange ('{' expression* '}'))
//  ;

triple
  : tripleItem tripleItem tripleItem
  ;

triple_with_dot
  : triple  '.'
  ;

predicate
  : 'a' | PNAME_NS WORD
  ;

tripleItem
  : VARIABLE | predicate
  ;

temporalOperator
  : always_in_past | always_in_future | sometime_in_past | sometime_in_future
  ;

   always_in_past
    : ('ALWAYS' 'IN' 'PAST') | ('always' 'in' 'past')
    ;

   always_in_future
    : ('ALWAYS' 'IN' 'FUTURE') | ('always' 'in' 'future')
    ;

   sometime_in_past
    : ('SOMETIME' 'IN' 'PAST') | ('sometime' 'in' 'past')
    ;

   sometime_in_future
    : ('SOMETIME' 'IN' 'FUTURE') | ('SOMETIME' 'IN' 'FUTURE')
    ;

temporalRange
  : begin_inc DURATION ',' DURATION end_inc
  ;

 begin_inc
    : '(' | '['
    ;

  end_inc
    : ')' | ']'
    ;


comparisonExpression
  : (VARIABLE COMPARATOR VARIABLE) | (VARIABLE COMPARATOR literal)
  | (literal COMPARATOR VARIABLE)
  ;

literal
  : INTEGER | DECIMAL | DOUBLE | BOOLEAN | string
  ;

string
  : '\'' WORD '\''
  ;
//COMMENT
//: '//' (~( [\r | \n] ))*  -> skip
//;

WS
  : ([\t\r\n\u000C] | ' ') + -> skip
  ;
/*------------------------------------------------------------------
 * LEXER RULES
 Applied for tokenization (before parsing), regardless of parser rules, as follows:
 - The rule matching the longest substring is applied
 - If there are several of them, the first one is applied
 *------------------------------------------------------------------*/

DURATION
  : '0' | ([0-9]+ ('D' | 'H' | 'M' | 'S' | 'MS'))
  ;

INTEGER
  : [0-9] +
  ;

DECIMAL
  : [0-9]* '.' [0-9] +
  ;

DOUBLE
  : ([0-9] + '.' [0-9]* EXPONENT | '.' [0-9] + EXPONENT | [0-9] + EXPONENT)
  ;

BOOLEAN
  : 'true' | 'TRUE' | 'True' | 'false'| 'FALSE'| 'False'
  ;

EXPONENT
  : [eE] [+-]? [0-9] +
  ;

COMPARATOR
  : '>' | '<' | '>=' | '<=' | '=' | '<>'
  ;




VARIABLE
  : '?' [a-zA-Z0-9]*
  ;

WORD
  : [a-zA-Z]+ [a-zA-Z0-9]*
  ;

IRIREF
  : '<' IRIREF_INNER_CHAR* '>'
  ;

PNAME_NS
  : PN_PREFIX? ':'
  ;

PN_PREFIX
  : PN_CHARS_BASE ((PN_CHARS | '.')* PN_CHARS)?
  ;

PN_CHARS_U
  : PN_CHARS_BASE | '_'
  ;

PN_CHARS
  : PN_CHARS_U | '-' | [0-9] | '\u00B7' | [\u0300-\u036F] | [\u203F-\u2040]
  ;

PN_CHARS_BASE
  : 'A' .. 'Z' | 'a' .. 'z' | '\u00C0' .. '\u00D6' | '\u00D8' .. '\u00F6' | '\u00F8' .. '\u02FF' | '\u0370' .. '\u037D' | '\u037F' .. '\u1FFF' | '\u200C' .. '\u200D' | '\u2070' .. '\u218F' | '\u2C00' .. '\u2FEF' | '\u3001' .. '\uD7FF' | '\uF900' .. '\uFDCF' | '\uFDF0' .. '\uFFFD'
  ;

UCHAR
  : '\\u' HEX HEX HEX HEX | '\\U' HEX HEX HEX HEX HEX HEX HEX HEX
  ;

HEX
  : [0-9] | [A-F] | [a-f]
  ;


fragment IRIREF_INNER_CHAR
  :  (PN_CHARS | '.' | ':' | '/' | '\\' | '#' | '@' | '%' | '&' | UCHAR)
  ;