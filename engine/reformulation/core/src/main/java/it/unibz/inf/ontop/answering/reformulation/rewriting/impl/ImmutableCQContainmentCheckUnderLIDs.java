package it.unibz.inf.ontop.answering.reformulation.rewriting.impl;

import com.google.common.collect.*;
import com.google.inject.Inject;
import com.google.inject.assistedinject.Assisted;
import it.unibz.inf.ontop.answering.reformulation.rewriting.ImmutableCQ;
import it.unibz.inf.ontop.answering.reformulation.rewriting.ImmutableCQContainmentCheck;
import it.unibz.inf.ontop.answering.reformulation.rewriting.ImmutableLinearInclusionDependenciesTools;
import it.unibz.inf.ontop.datalog.*;
import it.unibz.inf.ontop.model.atom.AtomPredicate;
import it.unibz.inf.ontop.model.atom.DataAtom;
import it.unibz.inf.ontop.model.term.Variable;
import it.unibz.inf.ontop.model.term.VariableOrGroundTerm;
import it.unibz.inf.ontop.utils.ImmutableCollectors;

import java.util.*;
import java.util.function.Function;

public class ImmutableCQContainmentCheckUnderLIDs implements ImmutableCQContainmentCheck {

    private final Map<ImmutableList<DataAtom>, ImmutableMultimap<AtomPredicate, DataAtom>> chaseCache = new HashMap<>();

    private final ImmutableMultimap<AtomPredicate, ImmutableLinearInclusionDependency<AtomPredicate>> dependencies;

    private final ImmutableHomomorphismUtilities homomorphismUtilities;
    private final ImmutableLinearInclusionDependenciesTools inclusionDependencyTools;

    @Inject
    public ImmutableCQContainmentCheckUnderLIDs(@Assisted ImmutableMultimap<AtomPredicate,
                                                ImmutableLinearInclusionDependency<AtomPredicate>> dependencies,
                                                ImmutableHomomorphismUtilities homomorphismUtilities,
                                                ImmutableLinearInclusionDependenciesTools inclusionDependencyTools) {
        this.dependencies = dependencies;
        this.homomorphismUtilities = homomorphismUtilities;
        this.inclusionDependencyTools = inclusionDependencyTools;
    }

    @Override
    public boolean isContainedIn(ImmutableCQ cq1, ImmutableCQ cq2) {

        ImmutableMultimap<AtomPredicate, DataAtom> chase1 = getChasedAtoms(cq1.getAtoms());

        // just to speed up the check in case there can be no match
        if (cq2.getAtoms().stream().anyMatch(a -> !chase1.containsKey(a.getPredicate())))
            return false;

        Map<Variable, VariableOrGroundTerm> sb = new HashMap<>();
        // get the substitution for the answer variables first
        // this will ensure that all answer variables are mapped either to constants or
        //       to answer variables in the base (but not to the labelled nulls generated by the chase)
        boolean headResult = homomorphismUtilities.extendHomomorphism(sb, cq2.getAnswerVariables(), cq1.getAnswerVariables());
        if (!headResult)
            return false;

        return homomorphismUtilities.hasSomeHomomorphism(sb, cq2.getAtoms(), chase1);
    }

    private ImmutableMultimap<AtomPredicate, DataAtom> getChasedAtoms(ImmutableList<DataAtom> atoms) {
        ImmutableMultimap<AtomPredicate, DataAtom> result = chaseCache.get(atoms);
        if (result == null) {
            result = ((dependencies == null)
                        ? atoms.stream()
                        : Sets.union(ImmutableSet.copyOf(atoms),
                            atoms.stream()
                                .flatMap(a -> inclusionDependencyTools.chaseAtom(a, dependencies.get(a.getPredicate())).stream())
                                .collect(ImmutableCollectors.toSet())).stream())
                    .collect(ImmutableCollectors.toMultimap(DataAtom::getPredicate, Function.identity()));
            chaseCache.put(atoms, result);
        }
        return result;
    }


}
